# ---------- Interactive shell: keep startup lean; lazy-load the rest ----------

# Ensure cache dir exists (used by compinit dump & zcompile artifacts)
export ZSH_CACHE_DIR="${ZSH_CACHE_HOME:-${XDG_CACHE_HOME:-$HOME/.cache}}/zsh"
mkdir -p "$ZSH_CACHE_DIR"

# 0) Options tuned for snappy interactivity
setopt autocd
setopt interactivecomments
setopt histignoredups sharehistory
setopt glob_dots
setopt extendedglob
setopt promptsubst
unsetopt beep

# 1) Instant minimal prompt (no blocking disk reads)
PROMPT='%F{cyan}%n%f %F{blue}%~%f %# '

# 2) Fast, cached completion
autoload -Uz compinit add-zsh-hook
_compdump="$ZSH_CACHE_DIR/zcompdump"
if [[ -r $_compdump ]]; then
  compinit -C -d "$_compdump"
else
  _lazy_compinit() {
    compinit -i -d "$_compdump"
    add-zsh-hook -d precmd _lazy_compinit
  }
  add-zsh-hook precmd _lazy_compinit
fi
zstyle ':completion:*' rehash true
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=** r:|=**'

# 3) Robust defer: queue commands, run them once at first prompt, then unhook
typeset -ga _defer_queue=()
defer() { _defer_queue+=("$*"); }
_run_deferred() {
  add-zsh-hook -d precmd _run_deferred
  local cmd
  for cmd in "${_defer_queue[@]}"; do
    builtin eval -- "$cmd"
  done
  unset _defer_queue
  unset -f defer _run_deferred
}
add-zsh-hook precmd _run_deferred

# 4) oh-my-zsh: defer heavy framework until after first prompt
export ZSH="$HOME/.oh-my-zsh"
export ZSH_THEME=""
plugins=(git)
defer '[[ -r "$ZSH/oh-my-zsh.sh" ]] && source "$ZSH/oh-my-zsh.sh"'

# 5) Prompt: switch to Spaceship AFTER the shell is responsive, but start its async worker now
defer '
if command -v brew >/dev/null 2>&1; then
  _sp="$(brew --prefix)/opt/spaceship/spaceship.zsh"
  if [[ -r "$_sp" ]]; then
    SPACESHIP_PROMPT_ASYNC=false
    source "$_sp"
  fi
fi
unset _sp
'

# 6) Syntax highlighting & autosuggestions: load late
defer '
hb="$(command -v brew >/dev/null 2>&1 && brew --prefix || echo /opt/homebrew)"
ASG="$hb/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
HL="$hb/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
[[ -r "$ASG" ]] && source "$ASG"
[[ -r "$HL"  ]] && source "$HL"
unset hb ASG HL
'

# 7) NVM: load on first use
export NVM_DIR="$HOME/.nvm"
_nvm_lazy_source() {
  local nvm_sh="/opt/homebrew/opt/nvm/nvm.sh"
  [[ -s "$nvm_sh" ]] && . "$nvm_sh"
}
for _tool in node npm npx pnpm yarn corepack; do
  eval "
  ${_tool}() {
    unfunction ${_tool} 2>/dev/null || true
    _nvm_lazy_source
    command ${_tool} \"\$@\"
  }"
done
nvm() { unfunction nvm 2>/dev/null || true; _nvm_lazy_source; command nvm "$@"; }

# 8) zoxide
if command -v zoxide >/dev/null 2>&1; then
  eval "$(zoxide init --cmd cd zsh)"
fi

# 9) Bat/eza
if command -v eza >/dev/null 2>&1; then
  alias ls='eza --icons --header --git'
  alias lt='eza --icons --tree'
  alias l='ls -l'
  alias la='ls -lAh'
fi
if command -v bat >/dev/null 2>&1; then
  export BAT_THEME='base16'
  alias cat='bat'
fi

# 10) Aliases & helpers
alias clr='clear'
alias q='cd ~ && clear'
[[ -d ~/Downloads ]] && alias dl='cd ~/Downloads'
[[ -d ~/Desktop  ]]  && alias dt='cd ~/Desktop'
[[ -d ~/Code     ]]  && alias pj='cd ~/Code'
alias -- +x='chmod +x'
alias x+='chmod +x'
alias oo='open .'
alias term='open -a iTerm.app'
alias reload='source "$HOME/.zshrc"'
alias get='curl -O -L'
command -v tldr >/dev/null 2>&1 && alias help='tldr'
alias git-root='cd "$(git rev-parse --show-toplevel 2>/dev/null || echo .)"'
alias path='print -l ${path}'
alias myip='ifconfig | sed -En "s/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p"'

# 11) Safer rm (optional)
# if command -v trash >/dev/null 2>&1; then
#   alias rm='trash'
# fi

# 12) Byte-compile after first prompt (uses defer queue, so safe)
for _zf in "$HOME/.zshrc" "$HOME/.zprofile"; do
  [[ -r "$_zf" ]] || continue
  _zc="${_zf}.zwc"
  if [[ ! -r "$_zc" || "$_zf" -nt "$_zc" ]]; then
    defer "zcompile -R -- '${_zc}' '${_zf}' 2>/dev/null || true"
  fi
done
unset _zf _zc _tool

